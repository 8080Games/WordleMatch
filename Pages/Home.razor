@page "/"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject WordleHelper.Services.WordleFilterService FilterService
@inject WordleHelper.Services.WordleStrategyService StrategyService
@using WordleHelper.Services
@using LetterState = WordleHelper.Services.WordleFilterService.LetterState

<PageTitle>Wordle Match</PageTitle>

<div class="wordle-container">
    @* NY Times Word List Update Notice *@
    <div class="update-banner">
        <div class="update-banner-content">
            <div class="banner-text">
                <strong>Updated:</strong> Wordle Match has reset the used words list in accordance with the NY Times announcement for February 2, 2026
            </div>
        </div>
    </div>

    <div class="theme-toggle">
        <button class="theme-btn" @onclick="ToggleTheme" title="@(isDarkMode ? "Switch to light mode" : "Switch to dark mode")" aria-label="@(isDarkMode ? "Switch to light mode" : "Switch to dark mode")">
            @(isDarkMode ? "☀️" : "🌙")
        </button>
    </div>

    <h1><img src="favicon.svg" alt="Wordle Match Icon" style="width: 32px; height: 32px; margin-right: 8px; vertical-align: middle;" />Wordle Match</h1>

    <input type="text" id="mobile-keyboard-input" class="mobile-keyboard-input" inputmode="text" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" />

    @* Display previous guesses *@
    @for (int guessIndex = 0; guessIndex < previousGuesses.Count; guessIndex++)
    {
        var currentGuessIndex = guessIndex;
        var (guessLetters, guessStates) = previousGuesses[guessIndex];
        <div class="previous-guess-row">
            <div class="elimination-count-container">
                <div class="elimination-count">-@GetEliminationCount(currentGuessIndex)</div>
            </div>
            <div class="guess-content-container">
                <div class="letter-boxes previous-guess">
                    @for (int i = 0; i < 5; i++)
                    {
                        int index = i;
                        <div class="letter-box-container">
                            <div class="letter-box @GetLetterClassForState(guessStates[index])">
                                @(guessLetters[index] == ' ' ? "" : guessLetters[index].ToString().ToUpper())
                            </div>
                        </div>
                    }
                </div>
            </div>
            <div class="delete-button-container">
                <button class="delete-guess-btn" @onclick="() => RemoveGuess(currentGuessIndex)" title="Remove this guess">×</button>
            </div>
        </div>
    }

    @* Current entry row *@
    <div class="entry-row">
        <div class="letter-boxes" id="letter-boxes-container">
            @for (int i = 0; i < 5; i++)
            {
                int index = i;
                <div class="letter-box-container">
                    <div class="letter-box @GetLetterClass(index) @GetFocusClass(index) @(lockedPositions[index] ? "locked" : "")"
                         tabindex="@(index + 1)"
                         @onclick="() => SetFocus(index)">
                        @(letters[index] == ' ' ? "" : letters[index].ToString().ToUpper())
                    </div>
                    @if (letters[index] != ' ' && !lockedPositions[index])
                    {
                        <div class="button-group">
                            <button class="state-button @GetStateButtonClass(index)"
                                    tabindex="@(7 + index)"
                                    title="@GetStateButtonTooltip(index)"
                                    @onclick="() => CycleState(index)"></button>
                        </div>
                    }
                </div>
            }
        </div>
        <button class="add-guess-btn" id="add-guess-btn" tabindex="6" @onclick="AddGuess" title="add new guess">+</button>
    </div>

    <div class="gameplay-mode-section">
        <span class="mode-label">Mode:</span>
        <div class="mode-toggle">
            <button class="mode-btn @(gameplayMode == GameplayMode.Normal ? "active" : "")" @onclick="() => SetGameplayMode(GameplayMode.Normal)">Normal</button>
            <button class="mode-btn @(gameplayMode == GameplayMode.Hard ? "active" : "")" @onclick="() => SetGameplayMode(GameplayMode.Hard)">Hard</button>
        </div>
    </div>

    <div class="instructions">
        Type letters from your Wordle guesses. Lowercase = excluded letter (white), Uppercase = letter in word but wrong position (yellow). Click the button to cycle through states. Press Space to leave a box empty (wildcard).
    </div>

    <div class="puzzle-info-container">
        <div class="puzzle-info">
            <button class="history-button" @onclick="OpenHistoryCalendar" title="Play past puzzles">
                <span class="material-icons">history</span>
            </button>
            <span class="puzzle-date">@userLocalDate.ToString("MMMM d, yyyy")</span>
            <span class="puzzle-separator">•</span>
            <span class="puzzle-number">Puzzle #@currentWordleGameNumber</span>
        </div>
    </div>

    <div class="recommendations-section">
        <div class="recommendations-header">
            <span class="recommendations-label">Recommendations:</span>
            <div class="mode-toggle">
                <button class="mode-btn @(strategyMode == StrategyMode.Off ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Off)">Off</button>
                <button class="mode-btn @(strategyMode == StrategyMode.On ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.On)">On</button>
            </div>
            @if (strategyMode == StrategyMode.On && gameplayMode == GameplayMode.Normal && previousGuesses.Count < 2)
            {
                <span class="normal-mode-waiting">Submit your @(previousGuesses.Count == 0 ? "first" : "second") guess (+) to see recommendations</span>
            }
            else if (isLoadingRecommendations)
            {
                <span class="loading-indicator">Calculating...</span>
            }
            else if (isRefiningRecommendations)
            {
                <span class="refining-indicator">✨</span>
            }
            else if (strategyMode != StrategyMode.Off && recommendations != null && recommendations.Any())
            {
                <div class="recommendations-list">
                    @foreach (var rec in GetDisplayRecommendations())
                    {
                        var wordType = rec.IsPossibleAnswer ? "Potential answer" : "Guess only word";
                        <span class="recommendation-item @(rec.IsPossibleAnswer ? "possible-answer" : "guess-only")"
                              title="Score: @rec.Score.ToString("F2") bits — @wordType">@rec.Word.ToUpper()</span>
                    }
                </div>
            }
        </div>
    </div>

    <div class="recommendations-section hints-section">
        <div class="recommendations-header">
            <span class="recommendations-label">Hints:</span>
            <div class="mode-toggle">
                <button class="mode-btn @(selectedHint == HintType.Vowels ? "active" : "")" @onclick="() => SetHint(HintType.Vowels)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Vowels</button>
                <button class="mode-btn @(selectedHint == HintType.Synonym ? "active" : "")" @onclick="() => SetHint(HintType.Synonym)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Synonym</button>
                <button class="mode-btn @(selectedHint == HintType.Haiku ? "active" : "")" @onclick="() => SetHint(HintType.Haiku)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Haiku</button>
                <button class="mode-btn @(selectedHint == HintType.Reveal ? "active" : "")" @onclick="() => SetHint(HintType.Reveal)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Reveal</button>
            </div>
        </div>
        @if (selectedHint != null && !string.IsNullOrEmpty(currentWordleWord))
        {
            <div class="hint-display">
                @if (selectedHint == HintType.Vowels)
                {
                    <span>Contains @currentWordVowelCount vowel@(currentWordVowelCount == 1 ? "" : "s")</span>
                }
                else if (selectedHint == HintType.Synonym && !string.IsNullOrEmpty(currentWordSynonym))
                {
                    <span>@currentWordSynonym</span>
                }
                else if (selectedHint == HintType.Haiku && !string.IsNullOrEmpty(currentWordHaiku))
                {
                    <div class="haiku-text">@currentWordHaiku.Replace(" / ", "\n")</div>
                }
                else if (selectedHint == HintType.Reveal)
                {
                    @if (!revealConfirmed)
                    {
                        <button class="reveal-confirm-btn" @onclick="ConfirmReveal">Are you sure?</button>
                    }
                    else
                    {
                        <span class="reveal-word">@currentWordleWord.ToUpper()</span>
                    }
                }
            </div>
        }
    </div>

    <div class="filter-buttons">
        <button class="filter-btn unused-btn @(wordFilter == WordFilter.Unused ? "active" : "")" @onclick="() => SetFilter(WordFilter.Unused)">unused</button>
        <button class="filter-btn both-btn @(wordFilter == WordFilter.Both ? "active" : "")" @onclick="() => SetFilter(WordFilter.Both)">both</button>
        <button class="filter-btn used-btn @(wordFilter == WordFilter.Used ? "active" : "")" @onclick="() => SetFilter(WordFilter.Used)">used</button>
    </div>

        <div class="results">
            <h2>Matching Words (@GetFilteredWords().Count())</h2>
            <div class="word-list">
                @foreach (var word in GetFilteredWords())
                {
                    if (usedWords.ContainsKey(word))
                    {
                        var (gameNumber, date) = usedWords[word];
                        // Only show as "used" if the game number is before today's game
                        if (gameNumber < currentWordleGameNumber)
                        {
                            <span class="used-word" title="Game #@gameNumber - @date">@word</span>
                        }
                        else
                        {
                            <span class="word">@word</span>
                        }
                    }
                    else
                    {
                        <span class="word">@word</span>
                    }
                }
            </div>
        </div>
</div>

<CalendarModal
    IsOpen="@showCalendarModal"
    SelectedDate="@userLocalDate"
    UsedWords="@usedWords"
    OnDateSelected="@OnHistoricalDateSelected"
    OnClose="@(() => showCalendarModal = false)" />

@code {
    private char[] letters = new char[5] { ' ', ' ', ' ', ' ', ' ' };
    private LetterState[] states = new LetterState[5];
    private bool[] lockedPositions = new bool[5];
    private int focusedIndex = 0;
    private List<string> allWords = new List<string>();
    private Dictionary<string, (int gameNumber, string date)> usedWords = new Dictionary<string, (int, string)>();
    private List<string> matchingWords = new List<string>();
    private DotNetObjectReference<Home>? dotNetRef;
    private WordFilter wordFilter = WordFilter.Both;
    private List<(char[] letters, LetterState[] states)> previousGuesses = new List<(char[], LetterState[])>();
    private List<WordleStrategyService.Recommendation>? recommendations = null;
    private StrategyMode strategyMode = StrategyMode.Off;
    private GameplayMode gameplayMode = GameplayMode.Normal;
    private bool isLoadingRecommendations = false;
    private bool isRefiningRecommendations = false;
    private bool isDarkMode = false;
    private bool showCalendarModal = false;

    // Wordle game info based on user's local date
    private DateTime userLocalDate = DateTime.Today; // Uses browser's local timezone
    private int currentWordleGameNumber = 0;
    private string currentWordleWord = string.Empty;
    private static readonly DateTime WordleStartDate = new DateTime(2021, 6, 19); // Wordle game 0

    // Hints for today's word
    private Dictionary<string, (string synonym, string haiku)> wordHints = new Dictionary<string, (string, string)>();
    private string currentWordSynonym = string.Empty;
    private string currentWordHaiku = string.Empty;
    private int currentWordVowelCount = 0;
    private HintType? selectedHint = null;
    private bool revealConfirmed = false;
    private bool hintsLoaded = false;

    private enum HintType
    {
        Vowels,
        Synonym,
        Haiku,
        Reveal
    }

    private enum WordFilter
    {
        Unused,
        Both,
        Used
    }

    private enum StrategyMode
    {
        Off,
        On
    }

    private enum GameplayMode
    {
        Normal,
        Hard
    }

    private IEnumerable<WordleStrategyService.Recommendation> GetDisplayRecommendations()
    {
        if (recommendations == null || !recommendations.Any())
            return Enumerable.Empty<WordleStrategyService.Recommendation>();

        // If there are 3 or fewer possible answers, ensure all of them are shown
        var possibleAnswers = recommendations.Where(r => r.IsPossibleAnswer).ToList();
        if (possibleAnswers.Count <= 3 && possibleAnswers.Count > 0)
        {
            // Get top 3 by score (might include strategic guess-only words)
            var top3 = recommendations.Take(3).ToList();

            // Combine top 3 with all possible answers, remove duplicates, maintain score order
            var combined = top3.Concat(possibleAnswers)
                .GroupBy(r => r.Word)
                .Select(g => g.First())
                .OrderByDescending(r => r.Score)
                .ToList();

            return combined;
        }

        var top3Default = recommendations.Take(3).ToList();

        // Check if any of the top 3 are solution words
        if (top3Default.Any(r => r.IsPossibleAnswer))
            return top3Default;

        // If none of the top 3 are solution words, find the first solution word in positions 4-5
        var solutionWord = recommendations.Skip(3).Take(2).FirstOrDefault(r => r.IsPossibleAnswer);

        if (solutionWord != null)
        {
            // Replace the 3rd recommendation with the solution word
            return new[] { top3Default[0], top3Default[1], solutionWord };
        }

        // No solution words in top 5, return top 3 as-is
        return top3Default;
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadWordLists();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupKeyboardListener", dotNetRef);
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("focusMobileInput");

            // Initialize theme based on localStorage or system preference
            await InitializeTheme();

            // Initialize game settings from localStorage
            await InitializeSettings();
        }
    }

    private async Task LoadWordLists()
    {
        try
        {
            // Load answer words first and display immediately
            var wordsText = await Http.GetStringAsync("words.txt");
            allWords = wordsText.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                .Select(w => w.Trim().ToLower())
                .Where(w => w.Length == 5)
                .ToList();

            // Initialize with answer words and refresh display
            matchingWords = allWords.OrderBy(w => w).ToList();
            StateHasChanged();

            // Calculate current game number first
            CalculateCurrentWordleGame();

            // Load guess-only words for strategy service
            var guessOnlyWords = await Http.GetStringAsync("guess-only-words.txt");
            StrategyService.Initialize(wordsText, guessOnlyWords);

            // Load word data based on sliding window architecture
            // Historical data: games 0-1687 (in historical-words.csv)
            // Current data: games 1688+ (in current-games.json with sliding 2-day window)
            if (currentWordleGameNumber <= 1687) // Historical games before word reuse era
            {
                // Historical games (0-1687): Use historical-words.csv
                await LoadHistoricalGameData();
            }
            else
            {
                // Current era games (1688+): Use current-games.json sliding window
                await LoadNewEraGameData();
            }

            // Re-calculate current word now that word data is loaded
            CalculateCurrentWordleGame();

            // Load pre-calculated performance data
            var startingWordsJson = await Http.GetStringAsync("starting-words.json");
            StrategyService.LoadStartingWords(startingWordsJson);

            var highQualityWordsJson = await Http.GetStringAsync("high-quality-words.json");
            StrategyService.LoadHighQualityWords(highQualityWordsJson);

            // Load second-word cache (optional)
            try
            {
                var secondWordCacheJson = await Http.GetStringAsync("second-word-cache.json");
                StrategyService.LoadSecondWordCache(secondWordCacheJson);
            }
            catch
            {
                Console.WriteLine("Second-word cache not found, using live calculation");
            }

            // Load master word hints
            await LoadMasterWordHints();

            // Look up hints for today's word now that hints are loaded
            LookupCurrentWordHints();

            // Final refresh after all data is loaded
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading word lists: {ex.Message}");
        }
    }

    private async Task LoadHistoricalGameData()
    {
        try
        {
            // Load historical word data for games 1-1690
            var historicalCsv = await Http.GetStringAsync("historical-words.csv");
            var historicalWords = new Dictionary<string, (int gameNumber, string date)>();

            foreach (var line in historicalCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',');
                if (parts.Length >= 3)
                {
                    var word = parts[0].Trim().ToLower();
                    if (word.Length == 5 && int.TryParse(parts[1].Trim(), out int gameNumber))
                    {
                        var date = parts[2].Trim();
                        historicalWords[word] = (gameNumber, date);
                        usedWords[word] = (gameNumber, date); // For UI compatibility
                    }
                }
            }

            // Pass historical words to strategy service
            StrategyService.LoadHistoricalWords(historicalWords);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading historical game data: {ex.Message}");
        }
    }

    private async Task LoadHistoricalGameUsedWords(int targetGameNumber)
    {
        try
        {
            // Clear existing used words
            usedWords.Clear();

            if (targetGameNumber <= 1688)
            {
                // Historical era (≤1688): Used words = all games from 1 to (targetGame - 1)
                Console.WriteLine($"Loading historical used words for game {targetGameNumber}: games 1-{targetGameNumber - 1}");

                var historicalCsv = await Http.GetStringAsync("historical-words.csv");
                var historicalWords = new Dictionary<string, (int gameNumber, string date)>();

                foreach (var line in historicalCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
                {
                    var parts = line.Split(',');
                    if (parts.Length >= 3)
                    {
                        var word = parts[0].Trim().ToLower();
                        if (word.Length == 5 && int.TryParse(parts[1].Trim(), out int gameNumber))
                        {
                            var date = parts[2].Trim();
                            historicalWords[word] = (gameNumber, date);

                            // Only include games before the target game (used words)
                            if (gameNumber < targetGameNumber)
                            {
                                usedWords[word] = (gameNumber, date);
                            }
                        }
                    }
                }

                // Pass all historical words to strategy service (not just used ones)
                StrategyService.LoadHistoricalWords(historicalWords);
            }
            else
            {
                // Word reuse era (≥1689): Used words = all games from 1689 to (targetGame - 1)
                Console.WriteLine($"Loading word reuse era used words for game {targetGameNumber}: games 1689-{targetGameNumber - 1}");

                // Load from used-words.csv (words that moved from current to historical)
                try
                {
                    var usedWordsCsv = await Http.GetStringAsync("used-words.csv");
                    foreach (var line in usedWordsCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
                    {
                        var parts = line.Split(',');
                        if (parts.Length >= 3)
                        {
                            var word = parts[0].Trim().ToLower();
                            if (word.Length == 5 && int.TryParse(parts[1].Trim(), out int gameNumber))
                            {
                                var date = parts[2].Trim();

                                // Only include games from 1689 to before target game
                                if (gameNumber >= 1689 && gameNumber < targetGameNumber)
                                {
                                    usedWords[word] = (gameNumber, date);
                                }
                            }
                        }
                    }
                }
                catch
                {
                    Console.WriteLine("No used-words.csv file found (expected for early word reuse era)");
                }

                // Load from current-games.json for games that haven't moved to historical yet
                try
                {
                    var currentGamesJson = await Http.GetStringAsync("current-games.json");
                    var currentGamesDocument = System.Text.Json.JsonDocument.Parse(currentGamesJson);
                    var gamesArray = currentGamesDocument.RootElement.GetProperty("games");

                    foreach (var gameElement in gamesArray.EnumerateArray())
                    {
                        var gameNumber = gameElement.GetProperty("gameNumber").GetInt32();
                        var word = gameElement.GetProperty("word").GetString()?.ToLower() ?? "";
                        var date = gameElement.GetProperty("date").GetString() ?? "";

                        // Only include games from 1689 to before target game
                        if (gameNumber >= 1689 && gameNumber < targetGameNumber)
                        {
                            usedWords[word] = (gameNumber, date);
                        }

                        // Load hints for current games into wordHints dictionary
                        if (gameElement.TryGetProperty("hints", out var hintsElement))
                        {
                            var synonym = hintsElement.TryGetProperty("synonym", out var synElement) ? synElement.GetString() ?? "" : "";
                            var haiku = hintsElement.TryGetProperty("haiku", out var haikuElement) ? haikuElement.GetString() ?? "" : "";
                            wordHints[word] = (synonym, haiku);
                        }
                    }
                }
                catch
                {
                    Console.WriteLine("No current-games.json file found");
                }

                // For word reuse era, pass empty historical words to strategy service
                StrategyService.LoadHistoricalWords(new Dictionary<string, (int, string)>());
            }

            Console.WriteLine($"Loaded {usedWords.Count} used words for game {targetGameNumber}");

            // Also find and set the current word for this historical game
            await SetHistoricalCurrentWord(targetGameNumber);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading historical game used words: {ex.Message}");
        }
    }

    private async Task SetHistoricalCurrentWord(int targetGameNumber)
    {
        try
        {
            // Look up the word for the target game number
            if (targetGameNumber <= 1687)
            {
                // Search historical-words.csv for the target game
                var historicalCsv = await Http.GetStringAsync("historical-words.csv");
                foreach (var line in historicalCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
                {
                    var parts = line.Split(',');
                    if (parts.Length >= 3 && int.TryParse(parts[1].Trim(), out int gameNumber))
                    {
                        if (gameNumber == targetGameNumber)
                        {
                            currentWordleWord = parts[0].Trim().ToLower();
                            currentWordVowelCount = CountVowels(currentWordleWord);
                            Console.WriteLine($"Set current word for game {targetGameNumber}: {currentWordleWord}");
                            return;
                        }
                    }
                }
            }
            else
            {
                // Search current-games.json for the target game
                var currentGamesJson = await Http.GetStringAsync("current-games.json");
                var currentGamesDocument = System.Text.Json.JsonDocument.Parse(currentGamesJson);
                var gamesArray = currentGamesDocument.RootElement.GetProperty("games");

                foreach (var gameElement in gamesArray.EnumerateArray())
                {
                    var gameNumber = gameElement.GetProperty("gameNumber").GetInt32();
                    if (gameNumber == targetGameNumber)
                    {
                        currentWordleWord = gameElement.GetProperty("word").GetString()?.ToLower() ?? "";
                        currentWordVowelCount = CountVowels(currentWordleWord);
                        Console.WriteLine($"Set current word for game {targetGameNumber}: {currentWordleWord}");
                        return;
                    }
                }
            }

            Console.WriteLine($"Warning: Could not find word for game {targetGameNumber}");
            currentWordleWord = string.Empty;
            currentWordVowelCount = 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error setting historical current word: {ex.Message}");
            currentWordleWord = string.Empty;
            currentWordVowelCount = 0;
        }
    }

    private async Task LoadNewEraGameData()
    {
        try
        {
            // New era after NY Times reset: No used words, all words available
            // Clear any used words tracking for the new word reuse era
            usedWords.Clear();

            // Load words from NY Times reset point (game 1689+)
            // First load any transition period words (1689+) that aren't in current-games.json
            try
            {
                var usedWordsText = await Http.GetStringAsync("used-words.csv");
                var lines = usedWordsText.Split('\n', StringSplitOptions.RemoveEmptyEntries);

                foreach (var line in lines.Skip(0)) // No header in used-words.csv
                {
                    var parts = line.Split(',');
                    if (parts.Length >= 3)
                    {
                        var word = parts[0].Trim().ToLower();
                        var gameNumber = int.Parse(parts[1].Trim());
                        var date = parts[2].Trim();

                        // Only include games from reset point (1689+) and before current game
                        if (gameNumber >= 1689 && gameNumber < currentWordleGameNumber)
                        {
                            usedWords[word] = (gameNumber, date);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Note: Could not load used-words.csv transition data: {ex.Message}");
            }

            // Load current-games.json with two possible words for timezone handling
            try
            {
                var currentGamesJson = await Http.GetStringAsync("current-games.json");
                var currentGamesDocument = System.Text.Json.JsonDocument.Parse(currentGamesJson);

                // Parse games array to find today's word
                var gamesArray = currentGamesDocument.RootElement.GetProperty("games");
                foreach (var gameElement in gamesArray.EnumerateArray())
                {
                    var gameNumber = gameElement.GetProperty("gameNumber").GetInt32();
                    var word = gameElement.GetProperty("word").GetString()?.ToLower() ?? "";
                    var date = gameElement.GetProperty("date").GetString() ?? "";

                    // Track words from the current games file
                    // Only mark as "used" if from a previous date (gameNumber < current)
                    if (gameNumber < currentWordleGameNumber)
                    {
                        usedWords[word] = (gameNumber, date);
                    }
                    else
                    {
                        // Today's word or future words - store for hints but don't mark as used
                        // This allows today's word to show as green (possible answer) instead of yellow
                    }

                    // Load hints for current games into wordHints dictionary
                    if (gameElement.TryGetProperty("hints", out var hintsElement))
                    {
                        var synonym = hintsElement.TryGetProperty("synonym", out var synElement) ? synElement.GetString() ?? "" : "";
                        var haiku = hintsElement.TryGetProperty("haiku", out var haikuElement) ? haikuElement.GetString() ?? "" : "";
                        wordHints[word] = (synonym, haiku);
                    }

                    // Pass the current game data to strategy service if it matches
                    if (gameNumber == currentWordleGameNumber)
                    {
                        StrategyService.LoadTodaysWord(gameElement);
                    }
                }

                // Also pass the recent used words array to strategy service
                if (currentGamesDocument.RootElement.TryGetProperty("recentUsedWords", out var recentUsedElement))
                {
                    // Create a synthetic document for the strategy service
                    var syntheticData = System.Text.Json.JsonDocument.Parse($"{{\"recentUsedWords\": {recentUsedElement.GetRawText()}}}");
                    // Note: Strategy service will handle the recent used words from the individual game elements
                }
            }
            catch
            {
                // No current-games.json yet - that's fine, all words are available
                Console.WriteLine("No current games file found - all words available for new era");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading new era game data: {ex.Message}");
        }
    }

    private async Task LoadMasterWordHints()
    {
        try
        {
            // Load master word hints (comprehensive source file)
            var hintsCsv = await Http.GetStringAsync("55ee0527d71c36d8-wordle-hints.csv");
            foreach (var line in hintsCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',', 3); // Split into max 3 parts to handle commas in haiku
                if (parts.Length >= 3 && parts[0] != "word") // Skip header
                {
                    var word = parts[0].Trim().ToLower();
                    var synonym = parts[1].Trim();
                    var haiku = parts[2].Trim().Trim('"'); // Remove quotes if present
                    wordHints[word] = (synonym, haiku);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading master word hints: {ex.Message}");
        }
    }

    private async Task LoadHistoricWordHints()
    {
        if (hintsLoaded) return; // Already loaded

        try
        {
            Console.WriteLine("Loading historic word hints...");
            // Load historic word hints (file with all historical Wordle puzzle hints)
            var hintsCsv = await Http.GetStringAsync("word_hints_historical.csv");
            foreach (var line in hintsCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',', 3); // Split into max 3 parts to handle commas in haiku
                if (parts.Length >= 3 && parts[0] != "word") // Skip header
                {
                    var word = parts[0].Trim().ToLower();
                    var synonym = parts[1].Trim();
                    var haiku = parts[2].Trim().Trim('"'); // Remove quotes if present
                    // Files don't overlap, so just merge all entries
                    wordHints[word] = (synonym, haiku);
                }
            }
            hintsLoaded = true;
            Console.WriteLine("Historic word hints loaded successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading historic word hints: {ex.Message}");
        }
    }

    private void CalculateCurrentWordleGame()
    {
        // Calculate days since Wordle started (game 0 was June 19, 2021)
        currentWordleGameNumber = (userLocalDate - WordleStartDate).Days;

        // Look up today's word from the used words database
        var todayWordEntry = usedWords.FirstOrDefault(w => w.Value.gameNumber == currentWordleGameNumber);
        if (!todayWordEntry.Equals(default(KeyValuePair<string, (int, string)>)))
        {
            currentWordleWord = todayWordEntry.Key;
            currentWordVowelCount = CountVowels(currentWordleWord);
        }
        else
        {
            currentWordleWord = string.Empty;
            currentWordVowelCount = 0;
        }
    }

    private void OpenHistoryCalendar()
    {
        showCalendarModal = true;
    }

    private async Task OnHistoricalDateSelected(DateTime selectedDate)
    {
        userLocalDate = selectedDate;
        showCalendarModal = false;

        // Calculate which game this date represents
        CalculateCurrentWordleGame();

        // Special case: If user selected "today", load current game normally
        if (selectedDate.Date == DateTime.Today.Date)
        {
            Console.WriteLine("Selected today - loading current game normally");

            // Load current game data using normal path
            if (currentWordleGameNumber <= 1687)
            {
                await LoadHistoricalGameData();
            }
            else
            {
                await LoadNewEraGameData();
            }

            // Re-calculate current word now that word data is loaded
            CalculateCurrentWordleGame();

            // Load master hints for current game
            await LoadMasterWordHints();
        }
        else
        {
            Console.WriteLine($"Selected historical date {selectedDate:yyyy-MM-dd} (game {currentWordleGameNumber}) - loading historical view");

            // Load master hints (lazy loading for historical games)
            await LoadMasterWordHints();

            // Load used words based on the historical game era
            await LoadHistoricalGameUsedWords(currentWordleGameNumber);
        }

        LookupCurrentWordHints();
        FilterWords();
        StateHasChanged();
    }

    private int CountVowels(string word)
    {
        if (string.IsNullOrEmpty(word)) return 0;

        var vowels = new[] { 'a', 'e', 'i', 'o', 'u' };
        return word.ToLower().Count(c => vowels.Contains(c));
    }

    private void LookupCurrentWordHints()
    {
        // Look up hints for today's word (call this after hints are loaded)
        if (!string.IsNullOrEmpty(currentWordleWord))
        {
            var lookupWord = currentWordleWord.ToLower(); // Convert to lowercase for lookup
            if (wordHints.ContainsKey(lookupWord))
            {
                var hints = wordHints[lookupWord];
                currentWordSynonym = hints.synonym;
                currentWordHaiku = hints.haiku;
            }
            else
            {
                currentWordSynonym = string.Empty;
                currentWordHaiku = string.Empty;
            }
        }
        else
        {
            currentWordSynonym = string.Empty;
            currentWordHaiku = string.Empty;
        }
    }

    [JSInvokable]
    public async void HandleKeyPress(string key)
    {
        if (focusedIndex < 0) return;

        // Skip locked (inherited) positions
        if (lockedPositions[focusedIndex])
        {
            MoveToNextEditablePosition();
            return;
        }

        char keyChar = key[0];
        letters[focusedIndex] = char.ToLower(keyChar);

        if (char.IsLower(keyChar))
        {
            states[focusedIndex] = LetterState.White;
        }
        else if (char.IsUpper(keyChar))
        {
            states[focusedIndex] = LetterState.Yellow;
        }
        else if (keyChar == ' ')
        {
            states[focusedIndex] = LetterState.None;
        }

        // Move to next editable box
        MoveToNextEditablePosition();

        CheckAndFilterWords();
        StateHasChanged();

        // Auto-recalculate recommendations on each letter change
        // Hard mode: Always recalculate
        // Normal mode: Only recalculate from 3rd word onward
        if (strategyMode != StrategyMode.Off)
        {
            if (gameplayMode == GameplayMode.Hard || previousGuesses.Count >= 2)
            {
                await CalculateRecommendations();
            }
        }
    }

    private async void MoveToNextEditablePosition()
    {
        // Move to next non-locked box if not at the end, or focus + button if at the end
        int nextIndex = focusedIndex + 1;
        while (nextIndex < 5 && lockedPositions[nextIndex])
        {
            nextIndex++;
        }

        if (nextIndex < 5)
        {
            focusedIndex = nextIndex;
        }
        else
        {
            focusedIndex = -1;
            // Focus the + button after filling all boxes
            await JSRuntime.InvokeVoidAsync("focusAddGuessButton");
        }
    }

    [JSInvokable]
    public async void HandleBackspace()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
            if (focusedIndex < 0) return; // All boxes are locked
        }

        // Find the last non-locked (editable) box
        int lastEditableIndex = 4;
        while (lastEditableIndex >= 0 && lockedPositions[lastEditableIndex])
        {
            lastEditableIndex--;
        }

        // Check if there are any editable boxes before the current one
        bool hasEditableBoxBefore = false;
        for (int i = focusedIndex - 1; i >= 0; i--)
        {
            if (!lockedPositions[i])
            {
                hasEditableBoxBefore = true;
                break;
            }
        }

        // Check if current box has content
        bool hadContent = letters[focusedIndex] != ' ';

        if (hadContent)
        {
            // Box has content: delete it and stay on this box
            if (!lockedPositions[focusedIndex])
            {
                letters[focusedIndex] = ' ';
                states[focusedIndex] = LetterState.None;
            }
        }
        else
        {
            // Box is empty: move back one box and delete its content
            if (focusedIndex > 0 && hasEditableBoxBefore)
            {
                focusedIndex--;
                while (focusedIndex >= 0 && lockedPositions[focusedIndex])
                {
                    focusedIndex--;
                }
                if (focusedIndex < 0)
                {
                    focusedIndex = 0;
                }
                else if (!lockedPositions[focusedIndex])
                {
                    // Clear the box we moved to
                    letters[focusedIndex] = ' ';
                    states[focusedIndex] = LetterState.None;
                }
            }
        }

        CheckAndFilterWords();
        StateHasChanged();

        // Auto-recalculate recommendations on letter delete
        // Hard mode: Always recalculate
        // Normal mode: Only recalculate from 3rd word onward
        if (strategyMode != StrategyMode.Off)
        {
            if (gameplayMode == GameplayMode.Hard || previousGuesses.Count >= 2)
            {
                await CalculateRecommendations();
            }
        }
    }

    [JSInvokable]
    public void HandleArrowLeft()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        else if (focusedIndex > 0)
        {
            focusedIndex--;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleArrowRight()
    {
        // If no box is focused, focus the first non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 0;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        else if (focusedIndex < 4)
        {
            focusedIndex++;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        StateHasChanged();
    }

    private async void SetFocus(int index)
    {
        // Don't allow focusing on locked (inherited) boxes
        if (lockedPositions[index])
        {
            return;
        }

        focusedIndex = index;
        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("focusMobileInput");
    }

    private async void CycleState(int index)
    {
        if (letters[index] != ' ' && !lockedPositions[index])
        {
            states[index] = states[index] switch
            {
                LetterState.White => LetterState.Yellow,
                LetterState.Yellow => LetterState.Green,
                LetterState.Green => LetterState.White,
                _ => LetterState.White
            };
            CheckAndFilterWords();
            StateHasChanged();

            // Auto-recalculate recommendations on letter state change
            // Hard mode: Always recalculate
            // Normal mode: Only recalculate from 3rd word onward
            if (strategyMode != StrategyMode.Off)
            {
                if (gameplayMode == GameplayMode.Hard || previousGuesses.Count >= 2)
                {
                    await CalculateRecommendations();
                }
            }
        }
    }

    private string GetStateButtonClass(int index)
    {
        // Button shows the color of the NEXT state
        return states[index] switch
        {
            LetterState.White => "yellow-btn",
            LetterState.Yellow => "green-btn",
            LetterState.Green => "white-btn",
            _ => "yellow-btn"
        };
    }

    private string GetStateButtonTooltip(int index)
    {
        // Tooltip indicates what color the button will change TO
        return states[index] switch
        {
            LetterState.White => "Change to Yellow",
            LetterState.Yellow => "Change to Green",
            LetterState.Green => "Change to White",
            _ => "Change to Yellow"
        };
    }

    private void CheckAndFilterWords()
    {
        // Filter words if at least one letter is entered OR if there are previous guesses
        if (letters.Any(l => l != ' ') || previousGuesses.Any())
        {
            FilterWords();
        }
        else
        {
            // Show all words when no letters are entered and no previous guesses
            matchingWords = allWords.OrderBy(w => w).ToList();
        }
    }

    private void FilterWords()
    {
        var guesses = new List<WordleFilterService.Guess>();

        // Add current entry if it has non-locked letters
        bool hasNonLockedLetters = false;
        for (int i = 0; i < 5; i++)
        {
            if (letters[i] != ' ' && !lockedPositions[i])
            {
                hasNonLockedLetters = true;
                break;
            }
        }

        if (hasNonLockedLetters)
        {
            guesses.Add(new WordleFilterService.Guess(letters, states));
        }

        // Add all previous guesses
        foreach (var (guessLetters, guessStates) in previousGuesses)
        {
            guesses.Add(new WordleFilterService.Guess(guessLetters, guessStates));
        }

        matchingWords = FilterService.FilterWords(allWords, guesses).ToList();
    }

    private string GetLetterClass(int index)
    {
        return states[index] switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private string GetLetterClassForState(LetterState state)
    {
        return state switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private int GetEliminationCount(int guessIndex)
    {
        try
        {
            // Calculate words before this guess (up to but not including this guess)
            var guessesBefore = new List<WordleFilterService.Guess>();
            for (int i = 0; i < guessIndex; i++)
            {
                var (guessLetters, guessStates) = previousGuesses[i];
                guessesBefore.Add(new WordleFilterService.Guess(guessLetters, guessStates));
            }
            var wordsBefore = FilterService.FilterWords(allWords, guessesBefore).Count();

            // Calculate words after this guess (including this guess)
            var guessesAfter = new List<WordleFilterService.Guess>();
            for (int i = 0; i <= guessIndex; i++)
            {
                var (guessLetters, guessStates) = previousGuesses[i];
                guessesAfter.Add(new WordleFilterService.Guess(guessLetters, guessStates));
            }
            var wordsAfter = FilterService.FilterWords(allWords, guessesAfter).Count();

            return Math.Max(0, wordsBefore - wordsAfter);
        }
        catch
        {
            return 0;
        }
    }

    private async void AddGuess()
    {
        // Only add if at least one letter is entered
        if (letters.Any(l => l != ' '))
        {
            // Clone the current letters and states
            var guessLetters = (char[])letters.Clone();
            var guessStates = (LetterState[])states.Clone();
            previousGuesses.Add((guessLetters, guessStates));

            // Clear the entry boxes, but preserve green letters and mark them as locked (only in Hard mode)
            for (int i = 0; i < 5; i++)
            {
                if (gameplayMode == GameplayMode.Hard && states[i] == LetterState.Green)
                {
                    // Keep green letter and mark as locked (inherited) - Hard mode only
                    lockedPositions[i] = true;
                }
                else
                {
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }

            // Find first non-locked position to focus
            focusedIndex = 0;
            for (int i = 0; i < 5; i++)
            {
                if (!lockedPositions[i])
                {
                    focusedIndex = i;
                    break;
                }
            }

            CheckAndFilterWords();
            StateHasChanged();
            await JSRuntime.InvokeVoidAsync("focusMobileInput");
        }
    }

    private async void RemoveGuess(int index)
    {
        if (index >= 0 && index < previousGuesses.Count)
        {
            // Check if we're removing the last guess (immediately before current row)
            bool removingLastGuess = index == previousGuesses.Count - 1;

            previousGuesses.RemoveAt(index);

            // If we removed the last guess, recalculate locked positions
            if (removingLastGuess)
            {
                RecalculateLockedPositions();
            }

            CheckAndFilterWords();
            StateHasChanged();

            // Auto-recalculate recommendations after removing a guess
            // Hard mode: Always recalculate
            // Normal mode: Only recalculate if still have 2+ previous guesses
            if (strategyMode != StrategyMode.Off)
            {
                if (gameplayMode == GameplayMode.Hard || previousGuesses.Count >= 2)
                {
                    await CalculateRecommendations();
                }
            }
        }
    }

    private void RecalculateLockedPositions()
    {
        // In Normal mode, just clear all locked positions
        if (gameplayMode == GameplayMode.Normal)
        {
            for (int i = 0; i < 5; i++)
            {
                if (lockedPositions[i])
                {
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }
        }
        // In Hard mode, rebuild locked positions from the new last guess
        else if (previousGuesses.Count > 0)
        {
            // Get the new last guess (which is now the one immediately before current row)
            var (lastGuessLetters, lastGuessStates) = previousGuesses[previousGuesses.Count - 1];

            for (int i = 0; i < 5; i++)
            {
                if (lastGuessStates[i] == LetterState.Green)
                {
                    // Inherit green letter from new last guess
                    letters[i] = lastGuessLetters[i];
                    states[i] = LetterState.Green;
                    lockedPositions[i] = true;
                }
                else if (lockedPositions[i])
                {
                    // Position was locked but new last guess doesn't have green here
                    // Clear this position
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }
        }
        else
        {
            // No previous guesses left, clear all locked positions
            for (int i = 0; i < 5; i++)
            {
                if (lockedPositions[i])
                {
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }
        }

        // Reset focus to first non-locked position
        focusedIndex = 0;
        for (int i = 0; i < 5; i++)
        {
            if (!lockedPositions[i])
            {
                focusedIndex = i;
                break;
            }
        }
    }

    private string GetFocusClass(int index)
    {
        return focusedIndex == index ? "focused" : "";
    }

    private async void SetFilter(WordFilter filter)
    {
        wordFilter = filter;

        // Save to localStorage
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "wordFilter", filter.ToString());
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving word filter: {ex.Message}");
        }

        StateHasChanged();
    }

    private void SetHint(HintType hint)
    {
        // Toggle hint: if already selected, deselect it; otherwise select it
        selectedHint = selectedHint == hint ? null : hint;

        // Reset reveal confirmation when switching hints
        revealConfirmed = false;

        StateHasChanged();
    }

    private void ConfirmReveal()
    {
        revealConfirmed = true;
        StateHasChanged();
    }

    private IEnumerable<string> GetFilteredWords()
    {
        return wordFilter switch
        {
            // Unused: words not in usedWords OR words with game number >= current game
            WordFilter.Unused => matchingWords.Where(w =>
                !usedWords.ContainsKey(w) ||
                usedWords[w].gameNumber >= currentWordleGameNumber),
            // Used: words in usedWords AND with game number < current game
            WordFilter.Used => matchingWords.Where(w =>
                usedWords.ContainsKey(w) &&
                usedWords[w].gameNumber < currentWordleGameNumber),
            _ => matchingWords
        };
    }

    private async Task SetStrategyMode(StrategyMode mode)
    {
        strategyMode = mode;

        // Save to localStorage
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "strategyMode", mode.ToString());
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving strategy mode: {ex.Message}");
        }

        if (mode == StrategyMode.Off)
        {
            recommendations = null;
            StateHasChanged();
            return;
        }

        // Auto-calculate when switching to On
        await CalculateRecommendations();
    }

    private async void SetGameplayMode(GameplayMode mode)
    {
        gameplayMode = mode;

        // Save to localStorage
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "gameplayMode", mode.ToString());
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving gameplay mode: {ex.Message}");
        }

        // Recalculate locked positions based on the new mode
        RecalculateLockedPositions();

        StateHasChanged();

        // Recalculate recommendations if they're enabled
        if (strategyMode != StrategyMode.Off)
        {
            await CalculateRecommendations();
        }
    }

    private async Task CalculateRecommendations()
    {
        if (strategyMode == StrategyMode.Off) return;

        // Normal mode now uses fast minimax algorithm instead of slow entropy
        bool isNormalMode = gameplayMode == GameplayMode.Normal;

        // Check if strategy service is initialized
        if (!StrategyService.IsInitialized)
        {
            Console.WriteLine("Strategy service not initialized yet");
            return;
        }

        // Normal mode: Only calculate after first two "+" clicks, then real-time for 3rd word onward
        if (isNormalMode && previousGuesses.Count < 2)
        {
            // For first two words: only calculate after "+" is clicked (no real-time)
            recommendations = null;
            StateHasChanged();
            return;
        }
        // For third word and beyond: continue with real-time calculations (like Hard mode)

        // For HARD mode: show cached starting words if first guess and <5 letterboxes filled
        // This prevents expensive calculations while user is typing their first word
        if (!isNormalMode && previousGuesses.Count == 0)
        {
            int filledCount = letters.Count(l => l != ' ');
            if (filledCount < 5)
            {
                // Use cached starting words - pass empty guesses list
                recommendations = StrategyService.GetRecommendations(new List<WordleFilterService.Guess>(), hardMode: true, topN: 5);
                StateHasChanged();
                return;
            }
        }

        isLoadingRecommendations = true;
        isRefiningRecommendations = false;
        StateHasChanged();

        await Task.Delay(1); // Allow UI to update

        try
        {
            var guesses = new List<WordleFilterService.Guess>();

            // Add all previous guesses
            foreach (var (guessLetters, guessStates) in previousGuesses)
            {
                guesses.Add(new WordleFilterService.Guess(guessLetters, guessStates));
            }

            // Add current entry if it has letters
            bool hasCurrentLetters = letters.Any(l => l != ' ');
            if (hasCurrentLetters)
            {
                guesses.Add(new WordleFilterService.Guess(letters, states));
            }

            bool isHardMode = gameplayMode == GameplayMode.Hard;

            if (isNormalMode)
            {
                // Normal mode: Use fast minimax algorithm (single phase - fast enough for direct results)
                recommendations = StrategyService.GetRecommendationsNormalModeMinimax(guesses, topN: 5);
                isLoadingRecommendations = false;
                isRefiningRecommendations = false;
                StateHasChanged();
                Console.WriteLine($"Normal mode minimax: Generated {recommendations?.Count ?? 0} recommendations");
            }
            else
            {
                // Hard mode: Use existing two-phase approach (quick then full)
                // Phase 1: Quick evaluation for instant feedback
                recommendations = StrategyService.GetRecommendations(guesses, isHardMode, topN: 5);
                isLoadingRecommendations = false;
                isRefiningRecommendations = true;  // Show refining indicator
                StateHasChanged();

                Console.WriteLine($"Quick: Generated {recommendations?.Count ?? 0} recommendations");

                // Phase 2: Full evaluation in background (only if not already cached)
                // Skip refinement if we got cached results (which are already optimal)
                bool isCachedResult = (guesses.Count == 0) ||
                                      (guesses.Count == 1 && !isHardMode);

                if (!isCachedResult)
                {
                    await Task.Delay(1); // Allow UI to update with quick results

                    var fullRecommendations = StrategyService.GetRecommendations(guesses, isHardMode, topN: 5, useMinimax: true);

                    // Update only if full recommendations are different/better
                    if (AreBetterRecommendations(fullRecommendations, recommendations))
                    {
                        recommendations = fullRecommendations;
                        StateHasChanged();
                        Console.WriteLine($"Full: Updated with {recommendations?.Count ?? 0} refined recommendations");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting recommendations: {ex.Message}");
            recommendations = null;
        }
        finally
        {
            isLoadingRecommendations = false;
            isRefiningRecommendations = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Checks if new recommendations are better than current ones
    /// Returns true if they're different and worth updating the UI
    /// </summary>
    private bool AreBetterRecommendations(
        List<WordleStrategyService.Recommendation>? newRecs,
        List<WordleStrategyService.Recommendation>? currentRecs)
    {
        if (newRecs == null || currentRecs == null)
            return false;

        if (newRecs.Count != currentRecs.Count)
            return true;

        // Check if top recommendation changed
        if (newRecs[0].Word != currentRecs[0].Word)
            return true;

        // Check if any scores improved significantly (>1% difference)
        for (int i = 0; i < Math.Min(newRecs.Count, currentRecs.Count); i++)
        {
            var scoreDiff = Math.Abs(newRecs[i].Score - currentRecs[i].Score);
            if (scoreDiff > 0.01)
                return true;
        }

        return false;
    }

    private async Task InitializeSettings()
    {
        try
        {
            // Load gameplay mode
            var savedGameplayMode = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "gameplayMode");
            if (!string.IsNullOrEmpty(savedGameplayMode) && Enum.TryParse<GameplayMode>(savedGameplayMode, out var parsedGameplayMode))
            {
                gameplayMode = parsedGameplayMode;
            }

            // Load strategy mode (recommendations on/off)
            var savedStrategyMode = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "strategyMode");
            if (!string.IsNullOrEmpty(savedStrategyMode) && Enum.TryParse<StrategyMode>(savedStrategyMode, out var parsedStrategyMode))
            {
                strategyMode = parsedStrategyMode;
            }

            // Load word filter (unused/both/used)
            var savedWordFilter = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "wordFilter");
            if (!string.IsNullOrEmpty(savedWordFilter) && Enum.TryParse<WordFilter>(savedWordFilter, out var parsedWordFilter))
            {
                wordFilter = parsedWordFilter;
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading settings: {ex.Message}");
        }
    }

    private async Task InitializeTheme()
    {
        try
        {
            // Check if there's a saved theme preference in localStorage
            var savedTheme = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "theme");

            if (!string.IsNullOrEmpty(savedTheme))
            {
                // Use saved preference
                isDarkMode = savedTheme == "dark";
            }
            else
            {
                // Check system preference
                var systemTheme = await JSRuntime.InvokeAsync<string>("getSystemThemePreference");
                isDarkMode = systemTheme == "dark";
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing theme: {ex.Message}");
        }
    }

    private async Task ToggleTheme()
    {
        isDarkMode = !isDarkMode;
        await ApplyTheme();
    }

    private async Task ApplyTheme()
    {
        try
        {
            var theme = isDarkMode ? "dark" : "light";

            // Save preference to localStorage
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "theme", theme);

            // Apply theme to DOM
            await JSRuntime.InvokeVoidAsync("setTheme", theme);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying theme: {ex.Message}");
        }
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
    }
}
